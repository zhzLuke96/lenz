# coding:utf-8
from clipper import BM, fmm, bmm
# from favor import favor


def clipper_test(_input):
    print(fmm(_input))
    print(bmm(_input))
    print(BM(_input))
    print("src:", _input)
    print()


print(BM("光看文本片段内部的凝合程度还不够，我们还需要从整体来看它在外部的表现。考虑“被子”和“辈子”这两个片段。我们可以说“买被子”、“盖被子”、“进被子”、“好被子”、“这被子”等等，在“被子”前面加各种字；但“辈子”的用法却非常固定，除了“一辈子”、“这辈子”、“上辈子”、“下辈子”，基本上“辈子”前面不能加别的字了。“辈子”这个文本片段左边可以出现的字太有限，以至于直觉上我们可能会认为，“辈子”并不单独成词，真正成词的其实是“一辈子”、“这辈子”之类的整体。可见，文本片段的自由运用程度也是判断它是否成词的重要标准。如果一个文本片段能够算作一个词的话，它应该能够灵活地出现在各种不同的环境中，具有非常丰富的左邻字集合和右邻字集合。"))

# text1 = "调用两种算法当结果完全相同则返回"
# text2 = "南京市长江大桥"
# text3 = "工信处女干事每月经过下属科室都要亲口交代24口交换机等技术性器件的安装工作"
# text4 = "正向最大匹配指的是从左到右对一个字符串进行匹配"
# clipper_test(text1)
# clipper_test(text2)
# clipper_test(text3)
# clipper_test(text4)
# clipper_test("目标是严肃活泼的技术流助眠师视频不露脸但爱瞎发自拍")
# clipper_test("长春市长春药店")
# clipper_test("九百九十一瓶娃哈哈畅饮10年")
#
# print()
# print(BM("所谓词典正向最大匹配就是将一段字符串进行分隔，其中分隔的长度有限制，然后将分隔的子字符串与字典中的词进行匹配，如果匹配成功则进行下一轮匹配，直到所有字符串处理完毕，否则将子字符串从末尾去除一个字，再进行匹配，如此反复。"))
#
# text1 = "有一个角色叫酱爆，他的梦想，是成为一个伟大的作曲家"
# text2 = "python真是一门糟糕透顶的语言"
# text2 = "python真是一门糟糕透顶的语言"
# text3 = "python虐我千百遍,我待python如初恋"
# text4 = "看哭了。难看哭了。"
# text5 = "我觉得这部电影唯一的正能量就是揭示了当代中国影业的乱象,不是电影中描述的,而是这部电影本身,就是一个搞笑的,无可救药的,荒诞的,具有历史性,纪实性,值得作为极端案例加以分析的,充满丑态的现实刻画"
# print(favor(text1))
# print(favor(text2))
# print(favor(text3))
# print(favor(text4))
# print(favor(text5))
#
# print(favor("看这书就一个字，爽。难以置信居然是教材。 虽然现在MIT已经不教lisp了，但是看这书学lisp绝对不吃亏。 程序员就是新世纪的魔法师！"))
